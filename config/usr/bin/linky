#!/usr/bin/env python3

import os
import subprocess
import sys

from enum import Enum
from datetime import datetime


class LogType(Enum):
    ERROR = "[ERROR]"
    WARN = "[WARN]"
    INFO = "[INFO]"
    RUN = "[RUN]"


def msg(msg: str, log_type=LogType.INFO):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f" [{timestamp}] {log_type.value} {msg}")
    sys.stdout.flush()


def execute(cmd: str):
    msg(cmd, LogType.RUN)
    subprocess.run(cmd, shell=True)


def init_version(path: str):
    execute(f"mkdir -p {path}")
    execute(f"echo 0 > {path}/.version")


def init_git(path: str):
    execute(f"git init {path}")
    execute(f"echo '*\n!*/\n*/**go\n!/**.gitignore' > {path}/.gitignore")
    execute(f"git -C {path} add .")
    execute(f'git -C {path} commit -m "Initial commit"')


def update_version(path: str, version: str):
    execute(f"echo {version} > {path}/.version")


def load_config_from_path(config_path: str):
    if not os.path.isfile(config_path):
        msg(f"No such file: {config_path}", LogType.ERROR)
        return None

    config_path = os.path.expanduser(config_path)
    config_dir = os.path.dirname(config_path)

    sys.path.insert(0, config_dir)

    try:
        module = __import__("config")
        return module
    except Exception as e:
        msg(f"Failed to import config from {config_path}: {e}", LogType.ERROR)
        return None
    finally:
        sys.path.pop(0)
        if "config" in sys.modules:
            del sys.modules["config"]


def execute_merge(target_dest: str, source: str):
    execute(f"rsync -a {target_dest} {source}")


def read_version(path: str):
    with open(path + "/.version", "r") as f:
        return f.readline().rstrip()


def rsync_files(origin_root: str, target_root: str, abs_path: str):
    source = origin_root + abs_path
    destination = target_root + abs_path
    if os.path.isdir(source):
        source += "/"
    msg(f"sync this: source:{source} -> destination:{destination}")
    os.makedirs(os.path.dirname(destination), exist_ok=True)
    execute_merge(source, destination)


def create_symlinks(final_conf):
    for value in final_conf.values():
        msg(f"value is: {value}")
        source = value[1]
        destination = value[0] + source
        msg(f"Creating symlinks at {source} to => {destination}")
        if os.path.exists(source):
            dirname = os.path.dirname(source)
            basename = os.path.basename(source)
            backup_path = os.path.join(dirname, f"bkp-{basename}")
            msg(f"path already exists creating backup")
            execute(f"mv -T --backup=numbered {source} {backup_path}")

        execute(f"mkdir -p {os.path.dirname(source)}")
        execute(f"ln -snf {destination} {source}")


def clean_up(cleanup_paths: list[str]):
    destination_root = cleanup_paths[0]
    source = cleanup_paths[1:]
    user_name = os.getenv("DEVELOPER", "unknown-user")

    for path in source:
        if os.path.exists(path):
            destination_folder = os.path.join(destination_root, user_name, os.path.dirname(path).lstrip("/"))
            os.makedirs(destination_folder, exist_ok=True)
            msg(f"Move {path} to {destination_folder}", LogType.INFO)
            execute(f"mv {path} {destination_folder}")
        else:
            msg(f"Path not found: {path}", LogType.WARN)



def main():
    config_path_list = sys.argv[1:]

    sys.dont_write_bytecode = True
    final_conf = {}
    for path in config_path_list:
        msg(f"Config Path: {path}")
        conf_module = load_config_from_path(path)
        if not conf_module:
            msg("Config load failed from: {path}", LogType.ERROR)
            continue

        for key in conf_module.__dict__:
            if key == "__presync_cleanup__":
                clean_up(conf_module.__dict__[key][0:])
            if not key.startswith("__") and not key.endswith("__"):
                curr_root_path = conf_module.__dict__[key][0]
                if not os.path.isdir(f"{curr_root_path}/.git"):
                    init_git(curr_root_path)
                if not os.path.isfile(f"{curr_root_path}/.version"):
                    init_version(curr_root_path)

                msg(f"Processing config key: {key}")
                curr_version = read_version(curr_root_path)
                updated_version = None
                for details in final_conf.values():
                    if details[2] == key:
                        msg(f"Found matching config: {details}")
                        prev_root_path = details[0]
                        match_absolute_path = details[1]
                        match_version = read_version(prev_root_path)
                        if match_version != curr_version:
                            rsync_files(prev_root_path, curr_root_path, match_absolute_path)
                            updated_version = match_version
                        final_conf[match_absolute_path][0] = curr_root_path

                if updated_version:
                    update_version(curr_root_path, updated_version)
                for i, layer in enumerate(conf_module.__dict__[key][1:]):
                    if layer in conf_module.__dict__[key][i + 2 :]:
                        msg(f"Duplicate key '{layer}' found in {key}.", LogType.WARN)
                    else:
                        final_conf[layer] = [curr_root_path, layer, key]
        for key in conf_module.__dict__:
            if key == "__postsync_cleanup__":
                clean_up(conf_module.__dict__[key][0:])
    create_symlinks(final_conf)


if __name__ == "__main__":
    main()
